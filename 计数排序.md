#                              计数排序

####          参考资料：https://www.cnblogs.com/kyoner/p/10604781.html

无论是归并排序，冒泡排序，还是快速排序等等，都是基于元素之间的比较来实现的。但现在有一个特殊的排序算法，是**计数排序**，利用数组下标的来确定元素的正确位置的排序方法。

优点：

在一些特殊的情况下，这种算法比快速排序还要快。

缺点：

- 当数列最大值和最小值差距过大时，并不适用于计数排序（浪费空间，算法复杂度也随之变高）
- 当数列元素不是整数时，并不适用（无法创建对应的统计数组，排序无法进行）

描述：

数组里取20个随机数，取值范围为从0~10，要求用最快的速度把这20从小到大排序。

思路：

先假设20个随机整数的值是：9, 3, 5, 4, 9, 1, 2, 7, 8，1，3, 6, 5, 3, 4, 0, 10, 9, 7, 9

让我们先遍历这个无序的随机数组，每一个整数按照其值对号入座，对应数组下标的元素进行加1操作。

比如第一个整数是9，那么数组下标为9的元素加1：

第二个整数是3，那么数组下标为3的元素加1：

继续遍历数列并修改数组......

最终，数列遍历完毕时，数组的状态如下：

<img src="C:\Users\chenxiaoxue\AppData\Roaming\Typora\typora-user-images\image-20200906142138797.png" alt="image-20200906142138797" style="zoom:80%;" />



数组中的每一个值，代表了数列中对应整数的出现次数。

有了这个统计结果，排序就很简单了，直接遍历数组，输出数组元素的下标值，元素的值是几，就输出几次：

0, 1, 1, 2, 3, 3, 3, 4, 4, 5, 5, 6, 7, 7, 8, 9, 9, 9, 9, 10

显然，这个输出的数列已经是有序的了。

这就是计数排序的基本过程，它适用于一定范围的整数排序。在取值范围不是很大的情况下，它的性能

在某些情况甚至快过那些O(nlogn)的排序，例如快速排序、归并排序。

代码实现如下：

```c++
public static int[] countSort(int[] array) {
    //1.得到数列的最大值
    int max = array[0];
    for (int i = 1; i < array.length; i++) {
        if (array[i] > max)
            max = array[i];
    }
    //2.根据数列的最大值确定统计数组的长度
    int[] coutArray = new int[max + 1];
    //3.遍历数列，填充统计数组
    for(int i = 0; i < array.length; i++)
        coutArray[array[i]]++;

    //4.遍历统计数组，输出结果
    int index = 0;
    int[] sortedArray = new int[array.length];
    for (int i = 0; i < coutArray.length; i++) {
        for (int j = 0; j < coutArray[i]; j++) {
            sortedArray[index++] = i;
        }
    }

    return sortedArray;
}

```

但是，这段代码限制因素太多了，实际我们数据范围不可能是从0-10，所以我们不能仅仅只考虑最大值

的大小，所以大小值都考虑到，这样才能确定一个范围。

除此之外，如果我们不仅仅只是数据的排序，还有于数据联系到一起的其他信息，比如学生的成绩和姓

名捆绑，当成绩相同时候，按输入的顺序输出学生姓名，这个时候我们该怎么去做呢？

例如：这里小红和小绿成绩相同，输出时怎么保证小红先输出呢？

![计算排序](D:\360极速浏览器下载\计算排序.jpg)

![将这些数据存储进数组后，发现当我们要求小红先输出的时候，我们无法做到。](D:\360极速浏览器下载\题解专用图片存储\计算排序.jpg)

对此，我们只需在填充完统计数组之后，对统计数组做一下变形。我们仍然以学生的成绩表为例，把之

前的统计数组进行变形，统计数组从第二个元素开始，每一个元素都加上前面所有元素之和：

![](D:\360极速浏览器下载\题解专用图片存储\计算排序2.jpg)

相加的目的就是为了让统计数组存储的元素值等于相应整数的最终排序位置。比如下标是9的元素值是

5，代表原始数列的整数9最终的排序是在第5位。

接下来，我们创建输出数组sortedArray，长度和输入数列一致，然后**从后向前**(因为需要先输入的数据

先输出）遍历输入数列：

**第一步**，遍历成绩表最后一行的小绿：小绿是95分，找到countArray下标为5的元素，值是4，代表小

绿的成绩排名是在第4位。

同时给countArray下标是5的元素值减1，从4变成3，代表着下次再遇到95分时，最终排名是第3位。

![](D:\360极速浏览器下载\题解专用图片存储\计算排序3.jpg)

 **第二步**，遍历成绩表倒数第二行的小白：小白是94分，找到countArray下标是4的元素，值是2，代表

小白的成绩排名在第2位。

同时，给countArray下标是4的元素值减1，从2变成1，代表下次再遇到94分的成绩时（实际上已经遇

不到了），最终排名是第1位。

![计算排序4](D:\360极速浏览器下载\题解专用图片存储\计算排序4.jpg)

因此，同样是95分的小红和小绿就能清楚地排出顺序，所以优化版的计数排序**属于稳定排序**。

后面的遍历过程依此类推。

代码如下：

```c++
public static int[] countSort(int[] array) {
        //1.得到数列的最大值与最小值，并算出差值d
        int max = array[0];
        int min = array[0];
        for (int i = 1; i < array.length; i++) {
            if (array[i] > max) {
                max = array[i];
            }
            if(array[i] < min) {
                min = array[i];
            }
        }
        int d = max - min;
        //2.创建统计数组并计算统计对应元素个数
        int[] countArray = new int[d + 1];
        for (int i = 0; i < array.length; i++) {
            countArray[array[i] - min]++;
        }
        //3.统计数组变形，后面的元素等于前面的元素之和
        int sum = 0;
        for (int i = 0; i < countArray.length; i++) {
            sum += countArray[i];
            countArray[i] = sum;
        }
        //4.倒序遍历原始数组，从统计数组找到正确位置，输出到结果数组
        int[] sortedArray = new int[array.length];
        for (int i = array.length - 1; i > 0; i--) {
            sortedArray[countArray[array[i] - min] - 1] = array[i];
            countArray[array[i] - min]--;
        }
        return sortedArray;
    }
```

如果原始数列的规模是N，最大最小整数的差值是M，由于代码中第1、2、4步都涉及到遍历原始数列，运算量都是N，第3步遍历统计数列，运算量是M，所以总体运算量是3N+M，去掉系数，**时间复杂度是O(N+M)**。这个时间复杂度看起来很友好，但是这个方法确实局限性太多了，常用的还是快速排序和冒泡排序。sort( )函数它不香嘛....