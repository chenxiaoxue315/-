#                      超级玛丽

来源：2020蓝桥省赛训练

问题描述

　　大家都知道"超级玛丽"是一个很善于跳跃的探险家，他的拿手好戏是跳跃，但它一次只能向前跳一步或两步。有一次，他要经过一条长为n的羊肠小道，小道中有m个陷阱，这些陷阱都位于整数位置，分别是a1,a2,....am，陷入其中则必死无疑。显然，如果有两个挨着的陷阱，则玛丽是无论如何也跳过不去的。
　　现在给出小道的长度n，陷阱的个数及位置。求出玛丽从位置1开始，有多少种跳跃方法能到达胜利的彼岸（到达位置n）。

输入格式

　　第一行为两个整数n,m
　　第二行为m个整数，表示陷阱的位置

输出格式

　　一个整数。表示玛丽跳到n的方案数

样例输入

4 1
2

样例输出

1

数据规模和约定

　　40>=n>=3,m>=1
　　n>m;
　　陷阱不会位于1及n上

思路：这是一题简单的动态规划，类似于爬楼梯的那题，只是用trap 布尔数组记录当前位置i是否是陷阱，如果不是就等于i - 1 和 i- 2的相加，如果是陷阱，dp值为0。

相当于有替丁限制的斐波拉契数组，如果没有陷阱，则为 1 1 2 3 5。。。。。，所以我们判断是否在陷阱位，如果在陷阱位dp[i]=0,如果不在则 dp[i]=dp[i-1]+dp[i-2]。

上代码：

```c++
#include<bits/stdc++.h>
using namespace std;
bool trap[50];
int dp[50];
int main ()
{
	int n,m;
	int i,temp;
	
	scanf("%d%d",&n,&m);
	for(i=1;i<=m;i++)
	{
		scanf("%d",&temp);
		trap[temp]=true;
	}
	dp[0]=0;
	dp[1]=1;
	for(i=2;i<=n;i++)
	{
		if(trap[i]==true)
		dp[i]=0;
		else
		dp[i]=dp[i-1]+dp[i-2];
	}
	printf("%d\n",dp[n]);
	return 0;
	
 }
```

